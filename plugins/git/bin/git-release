#!/usr/bin/env bash

## Git release
##
## My own git flow helper.
##
## Usage: git release <start/finish/list> [args]
##
## Subcommands:
##   start          Creates a new release branch
##   merge          Merge another branch using squash
##   finish         Merges the current branch into master and creates a tag
##   list           List all releases
##   prune          Delete archived branches (prefixed by archived/)
##

# Error handler
trap error_handler ERR

function error_handler {
  EXIT_CODE=$?

  echo
  echo "An error has occurred!"
  echo "Exit code: ${EXIT_CODE}"
  exit 1
}

function help {
  echo "usage:"
  echo
  echo "  git release start [name]   creates a new release branch."
  echo "                             if name is not specified, then it'll be vYY.M.S as in v16.1.1"
  echo "  git release merge [name]   merges a branch into the current selected release"
  echo "                             raises an error if you're not checked out in a release"
  echo "  git release finish [name]  merges the current release into master branch and creates a new tag"
  echo "                             if name is not specified, then it'll finish the last available release"
  echo "  git release list           list all releases"
  echo "  git release prune          delete all branches that has been archived"
}

function show_error {
  MSG=$1

  RED='\033[0;31m'
  NC='\033[0m'

  printf "[${RED}ERROR${NC}] ${MSG}\n"
  exit
}

function trim {
  awk '{$1=$1};1' | sed -e :a -e '/./,$!d;/^\n*$/{$d;N;};/\n$/ba'
}

function version_sort {
  sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n
}

function bump_version {
  VERSION=$1
  echo $VERSION | awk -F. '{$NF = $NF + 1;} 1' | sed 's/ /./g'
}

function branch_count {
  BRANCH_NAME=$1
  echo $(git branch --list "$BRANCH_NAME" | wc -l | trim)
}

function get_current_branch {
  git rev-parse --abbrev-ref HEAD
}

function update_branch {
  BRANCH_NAME=$1
  CURRENT_BRANCH=$(get_current_branch)

  git checkout $BRANCH_NAME
  git pull origin $BRANCH_NAME
  git checkout $CURRENT_BRANCH
}

function archive_branch {
  BRANCH_NAME=$1

  if [[ ! $BRANCH_NAME =~ /archived/ ]]; then
    git branch -m $BRANCH_NAME archived/$BRANCH_NAME
    echo "Branch '${BRANCH_NAME}' renamed to 'archived/${BRANCH_NAME}'"
  fi
}

# This function should not be called in a subshell because it needs TTY and sync output
# The best way to call it is on the same shell context, and it will set a variable
# called `$author`, so just use it.
function get_author {
  BASE_BRANCH=$1
  BRANCH_NAME=$2

  # Get branch author
  author=$(git log ${BASE_BRANCH}..${BRANCH_NAME} --oneline --format="%aN <%aE>" | tail -1)

  printf "Author of this branch: ${COLOR_LIGHT_GREEN}${author}${COLOR_NC}\n"
  read -p "Is that right? (Yn) " -n 1 -r
  echo

  if [[ ! $REPLY =~ ^[Yy]?$ ]]; then
    # Display a list of commiters on that branch
    IFS=$'\n'
    options=($(git log ${BASE_BRANCH}..${BRANCH_NAME} --oneline --format="%aN <%aE>" | sort | uniq))
    unset IFS

    echo
    echo "This is a list of people who committed code into this branch. Please select one of them:"

    select author in "${options[@]}"; do
      if [[ $author == "" ]]; then
        show_error "Please select a valid user!"
      fi

      break
    done
  fi
}

# Set variables based on user input
COMMAND=$1

# Colors
COLOR_NC='\e[0m'
COLOR_LIGHT_GREEN='\e[1;32m'
COLOR_LIGHT_RED='\e[1;31m'

if [[ $COMMAND != "" ]]; then
    case $COMMAND in
        start)
          # First argument is release_name
          RELEASE_NAME=$2

          if [[ $RELEASE_NAME = "" ]]; then

            # This command will search for a tag called vYY.M.S, being S any
            # decimal number - such as in v16.3.1 - and if does exist, it will
            # create a new branch bumping that version (v16.3.2).
            # However, if this branch exists, it'll try to create another branch
            # bumping that version (let's say v16.3.3).
            #
            # This is wanted because let's say you started working on a release
            # but then a bug came up, you just create another release and merge
            # the bugfix on it, then release it normally. After that you can
            # go back to work on you feature release.
            #
            # Be aware that is not possible to work in more than 2 releases at
            # the same time! Once you try to release a third one, it will just
            # just switch to the last one.

            BASE_VERSION=$(date +'%y.%-m')
            LAST_VERSION=$(git tag -l "v$BASE_VERSION.*" | version_sort | tail -1)

            # If we have a previous version, just bump it; otherwise start from 1
            if [[ $LAST_VERSION = "" ]]; then
              NEW_VERSION="v${BASE_VERSION}.1"
            else
              NEW_VERSION=$(bump_version $LAST_VERSION)
            fi

            # Now let's check if we're working on this branch already
            if [[ $(branch_count "release/$NEW_VERSION") != "0" ]]; then
              # Hey, we have a branch! Let's bump it again!
              NEW_VERSION=$(bump_version $NEW_VERSION)
            fi
          else
            NEW_VERSION=$RELEASE_NAME
          fi

          # Fine, now create the release branch
          git checkout -B release/$NEW_VERSION master

          echo
          echo "Merge work on it and then finish it by doing:"
          echo "  git release finish"
          ;;

        merge)
          # First argument is the branch name
          BRANCH_NAME=$2
          CURRENT_BRANCH=$(get_current_branch)

          if [[ $BRANCH_NAME = "" ]]; then
            show_error "Please, specify a branch name!"
          fi

          if [[ $(branch_count "$BRANCH_NAME") = "0" ]] && [[ $(git branch -r | grep "origin/$BRANCH_NAME") == "" ]]; then
            show_error "Branch not found (either locally or on origin)!"
          fi

          if [[ $(echo $CURRENT_BRANCH | \grep -E --only-matching 'release/.*') = "" ]]; then
            show_error "Please, check out into the release branch!"
          fi

          if [[ $(git status --porcelain | grep 'M') != "" ]]; then
            echo "This branch has staged files. Instead of trying to merge '${BRANCH_NAME}', we will just commit what is in it."
            echo
            echo "If that's not what you want, then your stage area before running this command."
            read -p "Continue? (Yn)" -n 1 -r
            echo

            if [[ $REPLY =~ ^[Nn]$ ]]; then
              exit
            fi

            # Get branch author and set $author variable
            get_author $CURRENT_BRANCH $BRANCH_NAME

            # Commit it
            git commit --author="$author"
            archive_branch $BRANCH_NAME
            exit
          fi

          # The branch is already local
          if [[ $(branch_count "$BRANCH_NAME") != "0" ]]; then
            read -p "Update this branch with origin? (Yn) " -n 1 -r
            echo

            if [[ ! $REPLY =~ ^[Yy]?$ ]]; then
              # Update the branch
              update_branch $BRANCH_NAME
            fi
          else
            # Update repo from origin
            git fetch origin

            # Update the branch
            update_branch $BRANCH_NAME
          fi

          # Get branch author and set `$author` variable
          get_author $CURRENT_BRANCH $BRANCH_NAME

          # Merges the branch using squash
          git merge --squash $BRANCH_NAME || GIT_ERROR=true

          if [[ $GIT_ERROR ]]; then
            show_error "Please, resolve your conflicts, add them to the staging area (git add .) and run this command again."
          fi

          # Commit it
          git commit --author="${author}"
          archive_branch $BRANCH_NAME
          ;;

        finish)
          # First argument is release_name
          RELEASE_NAME=$2

          if [[ $RELEASE_NAME = "" ]]; then
            RELEASE_BRANCH=$(git branch --list | \grep -E --only-matching 'release/.*' | version_sort | tail -1)

            if [[ $RELEASE_BRANCH = "" ]]; then
              show_error "No release branch was found."
            fi

            RELEASE_NAME=$(echo $RELEASE_BRANCH | sed 's/release\///')

          else
            if [[ $(branch_count "release/$RELEASE_NAME") = "0" ]]; then
              show_error "Branch not found!"
            else
              RELEASE_BRANCH="release/$RELEASE_NAME"
            fi
          fi

          echo "Merging $RELEASE_NAME back into master ..."

          # Create release message file
          RELEASE_MSG_FILE=".git/RELEASE_EDITMSG"
          if [[ ! -f $RELEASE_MSG_FILE ]]; then
            echo "Release ${RELEASE_NAME}" > $RELEASE_MSG_FILE
            echo "" >> $RELEASE_MSG_FILE
            echo "* ..." >> $RELEASE_MSG_FILE
            echo "#" >> $RELEASE_MSG_FILE
            echo "# Add you commit changelog here..." >> $RELEASE_MSG_FILE
            echo "# Lines starting with '#' will be ignored." >> $RELEASE_MSG_FILE
          fi

          # Checkout into master then merge it
          git checkout master
          git merge --no-ff $RELEASE_BRANCH

          # Generate a tag from master (unless it's created already)
          if ! [[ $(git tag -l | grep $RELEASE_NAME) ]]; then

            # Pick the best editor and edit the message
            _GIT_CONFIG_EDITOR=$(git config --get core.editor)
            TEXT_EDITOR="${GIT_EDITOR:-${_GIT_CONFIG_EDITOR:-${VISUAL:-EDITOR}}}"
            $TEXT_EDITOR $RELEASE_MSG_FILE

            # Tag it!
            git tag --sign $RELEASE_NAME -F $RELEASE_MSG_FILE
          fi

          # Delete release branch locally
          git branch -d $RELEASE_BRANCH

          for r in $(git remote); do
            # Delete release branch remotely
            if [[ $(git ls-remote --heads $r $RELEASE_BRANCH) != "" ]]; then
              git push $r --delete $RELEASE_BRANCH || true
            fi

            # Send both master and new tag to all remotes
            git push $r master
            git push $r $RELEASE_NAME
          done

          # Create the release draft
          git show $RELEASE_NAME -s --format="" \
            | sed -e '1,3d' \
              -e '/BEGIN PGP SIGNATURE/,/END PGP SIGNATURE/d' \
               > $RELEASE_MSG_FILE

          # Publish draft to GitHub
          # Make release through Github API
          # hub release create -f "$RELEASE_MSG_FILE" "$RELEASE_NAME" || true

          # Remove release message
          test -f $RELEASE_MSG_FILE && rm $RELEASE_MSG_FILE
          ;;

        prune)
          branch_count=$(git branch | grep 'archived/' | wc -l | trim)
          echo "Removing ${branch_count} archived branches..."

          for local_name in $(git branch | grep 'archived/' | cut -c 3-); do
            original_name=$(echo $local_name | sed -e 's/archived\///')
            printf "\nRemoving archived branch ${COLOR_LIGHT_GREEN}${original_name}${COLOR_NC}\n"

            for r in $(git remote); do
              git push --delete $r $original_name || true
              echo "  Removed from ${r}"
            done

            git branch -D $local_name
            echo "  Branch $original_name removed sucessfully!"
          done
          ;;

        list)
          printf "    ${COLOR_LIGHT_GREEN}Released (tags):$COLOR_NC\n"
          git tag -l "v*" | version_sort | column
          echo
          printf "    ${COLOR_LIGHT_RED}Unreleased (branches):$COLOR_NC\n"
          git branch --list | \grep -E --only-matching 'release/.*' | version_sort | column
          ;;

        help)
          help
          ;;

        *)
          echo "'$COMMAND' is not a valid command"
          echo
          help
          ;;
    esac
else
    echo "You must pass a parameter to release."
    help
fi
