#!/usr/bin/env bash

## GPG-Vault
## Wrapper over GPG to store encrypted files locally.
##
## Usage: gpg-vault <read/edit/write/exists> <file_path>
##
## Subcommands:
##   read          Decrypt and display the file in stdout
##   edit          Starts a EDITOR session to edit the file
##   write         Save the content of stdin encrypted into the file
##   exists        Checks whether the file exists (yes or no)
##   rekey         Rekey the entire path using the vault keys
##   import-keys   Import the keys from the vault into your keyring
##   export-keys   Used by 'rekey' command internally to regenerate
##                 the .vault-keys.asc file
##

# Set default variables
: ${GPG_VAULT_PATH:=$HOME/.gpg-vault}
: ${GPG_COMMAND:=gpg}

# Set version
VERSION="0.6"

# Path
ACTION=$1
FILEPATH=$2
FULLPATH=$GPG_VAULT_PATH/$FILEPATH

function help {
  echo "GPG-Vault v${VERSION}"
  echo ""
  echo "  This is just a wrapper of GPG to securely store files."
  echo "  It's not meant to store large files, so be reasonable."
  echo ""
  echo "Usage: $(basename $0) <read/edit/write/exists> <filepath>"
  echo ""
  echo "Actions:"
  echo "  read - Read the content of the file and print to stdout"
  echo "  edit - Using default editor, edits the encrypted file on the fly"
  echo "  write - Saves the content of the stdin into the file"
  echo "  exists - Checks whether the given file exists (yes or no)"
  echo "  rekey - Rekey the entire path using the vault keys"
  echo "  import-keys - Import the keys from the vault into your keyring"
  echo "  export-keys - Used by 'rekey' command internally to regenerate"
  echo "                the .vault-keys.asc file"
  echo ""
  echo "Extra:"
  echo "  By default, it uses ~/.gpg-vault as the basepath of gpg-vault."
  echo "  You can change it by setting GPG_VAULT_PATH environment variable."
  echo "  Set the default GPG command by changing the var GPG_COMMAND."
  exit 1
}

# Error handler
trap error_handler ERR

function error_handler {
  EXIT_CODE=$?

  echo
  echo "An error has occurred!"
  echo "Exit code: ${EXIT_CODE}"
  exit 1
}

# Parses a YAML file
#
function parse_yaml {
  local prefix=$2
  local s
  local w
  local fs
  s='[[:space:]]*'
  w='[a-zA-Z0-9_]*'
  fs="$(echo @|tr @ '\034')"
  sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
    -e "s|^\($s\)\($w\)$s[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" "$1" |
  awk -F"$fs" '{
  indent = length($1)/2;
  vname[indent] = $2;
  for (i in vname) {if (i > indent) {delete vname[i]}}
    if (length($3) > 0) {
      vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
      printf("%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, $3);
    }
  }' | sed 's/_=/+=/g'
}

# Finds the vault-keys file recursively
#
function find_vault_keys_file {
  local root="$1"
  while ! [[ "$root" =~ ^//[^/]*$ ]]; do
    if [ -e "${root}/.vault-keys" ]; then
      echo "${root}/.vault-keys"
      return 0
    fi
    [ -n "$root" ] || break
    root="${root%/*}"
  done
  return 1
}

# Ensure the variable $FILEPATH is not empty, regardless of its value
function verify_file_param {
  if [[ $FILEPATH == "" ]]; then
    echo "The filepath must be a valid path!"
    exit 1
  fi
}

# Set the variable $recipients with the key values
#
function list_vault_keys {
  local vault_path=$1
  local separator=$2
  local key=""

  # Locate the closest vault-keys file in the tree
  local vault_keys_file=$(find_vault_keys_file $vault_path || true)

  if [[ $vault_keys_file == "" ]]; then
    echo "File .vault-keys not found in tree '$vault_path'"
    return 1
  fi

  # Adds a `$config_keys` array
  eval $(parse_yaml "$vault_keys_file" config | grep keys)

  if [[ ${#config_keys[@]} == 0 ]]; then
    echo "File '$vault_keys_file' contains invalid keys section!"
    return 1
  fi

  for key in "${config_keys[@]}"; do
    key=$(echo $key | tr -d ' ')
    recipients="${recipients}${separator}${key}"
  done
}

# Validates all subcommands we support
if [[ $ACTION != "read" ]] &&
  [[ $ACTION != "edit" ]] &&
  [[ $ACTION != "write" ]] &&
  [[ $ACTION != "exists" ]] &&
  [[ $ACTION != "rekey" ]] &&
  [[ $ACTION != "import-keys" ]] &&
  [[ $ACTION != "export-keys" ]]
then
  help
  exit 1
fi

# Validates $GPG_VAULT_PATH
if [[ ! -w $GPG_VAULT_PATH ]]; then
  echo "The vault path (\$GPG_VAULT_PATH) dir is not writable!"
  exit 1
fi

case $ACTION in
  read)
    # Checks for $FILEPATH
    verify_file_param

    if [[ ! -f $FULLPATH.asc ]] || [[ ! -r $FULLPATH.asc ]]; then
      echo "File $FILEPATH does not exist or is not readable!"
      exit 1
    fi

    $GPG_COMMAND --decrypt --quiet $FULLPATH.asc
    ;;

  edit)
    # Checks for $FILEPATH
    verify_file_param

    tmp=`mktemp -t tmpgv` || exit 1

    # What editor are we going to use?
    if [[ $EDITOR != "" ]]; then
      editor=$EDITOR
    else
      editor=vi
    fi

    # More security for vi/[ngm]vim[r]
    if [[ $editor = "vi" ]] || [[ $editor == *"vim"* ]]; then
      # -n is for noswap and -i NONE is for no .viminfo
      editor="$editor -n -i NONE"
    fi

    # Figure the best way to delete the unencrypted temp file
    if [[ `which shred` ]]; then
      rm='shred -u'
    elif [[ "$OSTYPE" == "darwin"* ]]; then
      rm='rm -P'
    else
      rm='rm'
    fi

    # Decrypt into the tempfile, if it exists
    if [[ -f $FULLPATH.asc ]]; then

      if [[ ! -r $FULLPATH.asc ]]; then
        echo "File $FILEPATH exists but is not readable!"
        exit 1
      fi

      if [[ ! -w $FULLPATH.asc ]]; then
        echo "File $FILEPATH exists but is not writable!"
        exit 1
      fi

      $0 read $FILEPATH > $tmp
    fi

    # Edit the file and wait editor to finish
    # editor instance MUST be in blocking mode, not a daemon, otherwise it will fail
    $editor $tmp || true

    # Encrypt it back
    cat $tmp | $0 write $FILEPATH || true

    # Then erase it
    $rm $tmp
  ;;

  write)
    # Checks for $FILEPATH
    verify_file_param

    vault_path=$(dirname $FULLPATH)

    # Set $recipients here
    list_vault_keys "$vault_path" " -r "

    if [[ ! -f $vault_path ]]; then
      mkdir -p $vault_path
    fi

    if [[ -f "$FULLPATH.asc" ]] && [[ ! -w "$FULLPATH.asc" ]]; then
      echo "$FILEPATH isn't writable, no modifications are allowed!"
      exit 1
    fi

    $GPG_COMMAND --armor --encrypt --trust-model=always $recipients <&0 > $FULLPATH.asc
    ;;

  rekey)
    RED='\033[0;31m'
    GREEN='\e[1;32m'
    NC='\033[0m'

    if [[ ! -d "$GPG_VAULT_PATH/$FILEPATH" ]]; then
      echo "The specified folder '$GPG_VAULT_PATH/$FILEPATH' doesn't exist!"
      exit 1
    fi

    cd "$GPG_VAULT_PATH/$FILEPATH" || exit 1
    files=$(find . -type f -name "*.asc" ! -name ".vault-keys.asc" | sed -e 's/.asc$//' -e 's#^./##')
    file_count=$(echo "$files" | wc -l | bc)

    for file in $files; do
      full_file_path="$FILEPATH/$file"
      current=$((current + 1))

      printf "Rekeying file '${GREEN}$full_file_path${NC}' [$current/$file_count]\n"
      original_shasum=$($0 read $full_file_path | shasum)
      $0 read $full_file_path | $0 write $full_file_path

      printf "  Testing integrity...\n"
      if [[ $original_shasum != $($0 read $full_file_path | shasum) ]]; then
        printf "  ${RED}Rekeying file '$full_file_path' failed!${NC}\n"
      fi

      echo
    done

    # Save keys on .vault-keys.asc
    $0 export-keys $FILEPATH

    echo "$file_count files processed."
    ;;

  export-keys)
    GREEN='\e[1;32m'
    NC='\033[0m'

    # Checks for $FILEPATH
    verify_file_param

    # Locate all paths with .vault-keys in it
    cd "$GPG_VAULT_PATH/$FILEPATH" || exit 1
    paths=$(find . \( -type f -or -type l \) -name ".vault-keys" | sed -e 's#/.vault-keys$##' -e 's#^./##')

    for path in $paths; do
      # Set $recipients here
      list_vault_keys "$path" " "

      # Export keys to .vault-keys.asc
      keys_file="$GPG_VAULT_PATH/$FILEPATH/$path/.vault-keys.asc"
      $GPG_COMMAND --armor --export ${recipients} > "$keys_file"
      printf "Keys from '${GREEN}${FILEPATH}/${path}${NC}' exported successfully\n"
    done
    ;;

  import-keys)
    # Checks for $FILEPATH
    verify_file_param

    FULLPATH=${GPG_VAULT_PATH}/${FILEPATH}

    if ! test -r $FULLPATH; then
      echo "The specified path ($FULLPATH) does not exist or is not readable!"
      exit 1
    fi

    # Locate the closest vault-keys file in the tree
    vault_keys_file="$(find_vault_keys_file "$FULLPATH").asc"

    # Import the keys into the gpg keyring
    $GPG_COMMAND --import $vault_keys_file

    echo "Keys imported successfully!"
    ;;

  exists)
    # Checks for $FILEPATH
    verify_file_param

    if [[ -f $FULLPATH.asc ]]; then
      echo "yes"
      exit 0
    else
      echo "no"
      exit 1
    fi
esac
