#!/usr/bin/env python3
# vim: shiftwidth=4
#
# dotup - Update your existing configurations based on the dotfiles settings.
#
# External dependencies:
# - PyYAML (Arch: python-yaml, MacOS: pip3 install PyYAML)

from pathlib import Path
from typing import Any
from argparse import ArgumentParser
import os
import sys
import sqlite3
try:
    import yaml
except ImportError:
    print("PyYAML is not installed!")
    sys.exit(1)


class CLI:
    """
    Update your $HOME configuration files based upon the dotfiles arrangement.
    It reads the existing $HOME/.dotfiles/dotfiles.yml to decide which modules to load.

    If you don't pass the first argument, it is assumed that you meant `load` and the
    configuration will be reloaded.

    Scopes works like tags where you can tell the specifics about the environment you
    want to load the dotfiles at. If a specific entry of your `dotfiles.yml` contain a
    specific scope and it's not mentioned in this flag, then it will not be loaded.

    You can pass multiple scopes, and they will be required incrementally.

    Scopes can also be automatically loaded from a file `.dotup-scopes` so you don't
    have to specify them upon every run.
    """

    @staticmethod
    def start():
        """Entry point for this CLI application"""

        parser = ArgumentParser(prog="dotup", description=CLI.__doc__)
        parser.add_argument(
            "-s", "--scope", action="append", dest="scopes",
            help="list of defined scopes. it can be passed multiple times"
        )
        parser.add_argument(
            'command',
            choices=['load', 'unload'], default='load', nargs='?',
            help='action to run. (default: %(default)s)',
        )

        try:
            args = parser.parse_args()

            if args.command == 'load':
                Stower().load(scopes=args.scopes)
            elif args.command == 'unload':
                Stower().unload()

        # pylint: disable=broad-exception-caught
        except Exception as err:
        # pylint: enable=broad-exception-caught
            Term.error(err)


class State:
    """Manage the state database"""

    def __init__(self, file):
        self.file = file
        self.db = sqlite3.connect(file)
        self.state = {}

    def load(self):
        """Initialize the state database and load the existing state"""
        self.db.execute("CREATE TABLE IF NOT EXISTS links(path TEXT, PRIMARY KEY (path ASC)) STRICT")
        self.db.execute("CREATE TABLE IF NOT EXISTS local_links(path TEXT, PRIMARY KEY (path ASC)) STRICT")
        self.db.commit()
        self.db.row_factory = lambda cursor, row: row[0]
        self.state = {
            "links": self.db.execute("SELECT path FROM links").fetchall(),
            "local_links": self.db.execute("SELECT path FROM local_links").fetchall(),
        }

    def add_symlink(self, symlink):
        """Adds a reference of an added symlink to the state DB"""
        self.db.execute("INSERT INTO links(path) VALUES (?)", (symlink,))
        self.db.commit()
        self.state["links"].append(symlink)

    def add_local_symlink(self, symlink):
        """Adds a reference of a locally added symlink to the state DB"""
        self.db.execute("INSERT INTO local_links(path) VALUES (?)", (symlink,))
        self.db.commit()
        self.state["local_links"].append(symlink)

    def symlinks(self):
        """Retrieves a list of stored symlinks in the state DB"""
        return self.state["links"]

    def local_symlinks(self):
        """Retrieves a list of local-scoped symlinks stored in the state DB"""
        return self.state["local_links"]

    def erase_symlinks(self):
        """Erase the entire list of symlinks and local symlinks in the state DB"""
        self.state["links"] = []
        self.state["local_links"] = []
        self.db.execute("DELETE FROM links")
        self.db.execute("DELETE FROM local_links")
        self.db.commit()
        self.db.execute("VACUUM")


class Term:
    """
    All terminal output related functions
    """
    @staticmethod
    def status(*messages, indent = 1):
        """Formats and outputs a standardized status message in the terminal"""
        message = " ".join(str(msg) for msg in messages)
        pad_str = "  " * (indent - 1)
        print(f"\033[1m{pad_str} →\033[0m {message}")

    @staticmethod
    def success(*messages, indent = 1):
        """Formats and outputs a standardized success messages in the terminal"""
        message = " ".join(str(msg) for msg in messages)
        pad_str = "  " * (indent - 1)
        print(f"\033[1;32m{pad_str} ✔\033[0m \033[1m{message}\033[0m")

    @staticmethod
    def error(exception):
        """Formats and outputs a standardized exception message in the terminal"""
        err_title = "Error"
        indent = 0

        while True:
            if hasattr(exception, "__module__"):
                exc_name = ".".join([exception.__module__, type(exception).__name__])
            else:
                exc_name = exception.__class__.__name__

            indent_str = ' ' * indent
            print(f"{indent_str}\033[1m{err_title}:\033[0m \033[3;31m{exc_name}\033[0m: {exception}")
            if exception.__cause__:
                exception = exception.__cause__
                indent += 2
                err_title = "Caused by"
            else:
                return


class Stower:
    """
    Reads both existing state and dotfiles configuration and properly install them as necessary
    """
    dotfiles_path: str = ""
    destination_path: str = ""
    settings_path: str = ""
    state: State|None = None
    settings: dict[str, Any] = {}

    def __init__(self, dotfiles_path = "~/.dotfiles", destination_path = "~"):
        self.dotfiles_path = os.path.expanduser(dotfiles_path)
        self.destination_path = os.path.expanduser(destination_path)
        self.settings_path = f"{self.dotfiles_path}/dotfiles.yml"
        self.scopes_path = f"{self.dotfiles_path}/.dotup-scopes"

    def unload(self):
        """Unload all previously loaded dotfiles based on the state"""
        self._load_state()
        self._clear_symlinks()
        Term.status("Configuration unloaded")

    def load(self, scopes: list[str]|None = None):
        """With all settings loaded, this will setup all enabled modules"""
        Term.status("Loading settings")
        self._load_settings(scopes)
        self.unload()

        for module in self.settings["modules"]:
            self._load_module(module)

        Term.success("Dotfiles loaded successfully!")

    def _load_state(self):
        """Load the existing state database"""
        self.state = State(f"{self.dotfiles_path}/dotstate.db")
        self.state.load()

    def _load_settings(self, scopes: list[str]|None = None):
        """Load all dotfiles settings recursively"""
        try:
            self.settings = yaml.load(
                Path(self.settings_path).read_text("UTF-8"),
                Loader=yaml.loader.SafeLoader,
            )

            if not scopes:
                scopes_path = Path(self.scopes_path)
                if scopes_path.exists():
                    scopes = [scope.strip() for scope in scopes_path.read_text("UTF-8").strip().split("\n")]
                else:
                    scopes = []

            # Filter out modules that don't have the specified scopes
            def normalize_module(module):
                if isinstance(module, str):
                    return module

                if not isinstance(module, dict):
                    raise RuntimeError("The allowed types for modules are string or dict!")

                if "name" not in module:
                    raise RuntimeError("You must define a 'name' when defining a module using a dict!")

                if "scopes" in module:
                    if type(module["scopes"]) is str:
                        module["scopes"] = [module["scopes"]]

                    if not set(scopes).issubset(module["scopes"]):
                        return None

                return module["name"]

            self.settings["modules"] = filter(
                lambda m: m is not None,
                map(normalize_module, self.settings["modules"])
            )

        except Exception as err:
            raise RuntimeError(f"Failure to load settings from {self.settings_path}") from err

    def _module_path(self, module):
        return f"{self.dotfiles_path}/modules/{module}"

    def _load_module(self, module):
        Term.status(f"Loading module '{module}'")
        if not os.path.isdir(self._module_path(module)):
            raise RuntimeError(f"Module folder '{module}' not found")

        # Link include files
        self._load_module_symlinks(module)
        Term.status("Files linked", indent = 2)

        # Load shell config files
        self._load_module_shell_plugins(module)
        Term.status("Shell configured", indent = 2)

        # Load binary files
        self._load_module_bins(module)
        Term.status("Binary files linked", indent = 2)

    def _load_module_symlinks(self, module):
        for link in self._list_module_links(module):
            self._symlink(f"modules/{module}/include/{link}", link)

    def _load_module_shell_plugins(self, module):
        for link in self._list_module_shell_links(module):
            if link == "init.fish":
                dest = f"modules/fish/include/.config/fish/conf.d/module_{module}_init.fish"
            else:
                dest = f"modules/fish/include/.config/fish/modules/{link}"

            self._symlink_internal(f"modules/{module}/{link}", dest)

    def _load_module_bins(self, module):
        for file in self._list_module_bins(module):
            self._symlink(f"modules/{module}/bin/{file}", f".bin/{file}")

    def _list_module_shell_links(self, module) -> list[str]:
        module_path = self._module_path(module)
        shell_folders = ["completions", "functions"]

        linkable_files: list[str] = []
        for shell_folder in shell_folders:
            folder = f"{module_path}/{shell_folder}"
            if not os.path.isdir(folder):
                continue
            linkable_files += [f"{shell_folder}/{file}" for file in os.listdir(folder)]

        if os.path.exists(f"{module_path}/init.fish"):
            linkable_files.append("init.fish")

        return linkable_files

    def _list_module_links(self, module) -> list[str]:
        include_path = f"{self._module_path(module)}/include"
        if not os.path.isdir(include_path):
            return []

        linkable_paths: list[str] = []
        for root, _dirs, files in os.walk(include_path):
            rel_root = root.removeprefix(f"{include_path}").lstrip("/")

            # Just skips this entire folder if their parent is already marked for symlinking
            path_already_linked = [True for path in linkable_paths if rel_root.startswith(f"{path}/")]
            if path_already_linked:
                continue

            if root != include_path and not Stower.symlinked_denied(rel_root):
                linkable_paths.append(rel_root)
                continue

            for file in files:
                linkable_paths.append(os.path.join(rel_root, file))

        return linkable_paths

    def _list_module_bins(self, module) -> list[str]:
        bin_path = f"{self._module_path(module)}/bin"
        if not os.path.isdir(bin_path):
            return []

        return os.listdir(bin_path)

    @staticmethod
    def symlinked_denied(path) -> bool:
        """
        Returns whether the specified path is in the paths deny_list, meaning that this specific
        path can not be symlinked.

        E.g. If we're testing the path /etc and /etc/etcd is in the denylist, then /etc can't be
        symlinked because there's a child node that can't.
        """
        for denial in Stower.paths_denylist():
            if denial.startswith(path):
                return True
        return False

    @staticmethod
    def paths_denylist() -> list[str]:
        """This is a list of paths that shouldn't never be symlinked, only their child nodes"""
        return [
            ".local/share",              # XDG_DATA_HOME
            ".config",                   # XDG_CONFIG_HOME
            ".local/state",              # XDG_STATE_HOME
            ".cache",                    # XDG_CACHE_HOME
            ".gnupg",                    # GnuPG metadata
            ".config/vlc",               # VLC metadata
            ".config/pulse",             # PulseAudio
            ".config/systemd/user",      # SystemD user units
            ".local/share/applications", # Desktop entries
        ]

    def _symlink(self, origin, destination):
        """
        Creates a symlink between an origin inside dotfiles to a destination at destination_path
        """
        try:
            sym_from = f"{self.dotfiles_path}/{origin}"
            sym_to = f"{self.destination_path}/{destination}"

            if not os.path.exists(sym_from):
                raise RuntimeError(f"File {sym_from} was not found!")
            if os.path.exists(sym_to):
                # If the file is a symlink and it is already pointing to where we want to, just
                # include it into our state, otherwise let the user fix it.
                if os.path.islink(sym_to) and os.readlink(sym_to) == sym_from:
                    self.state.add_symlink(destination)
                    return

                raise RuntimeError(f"Path {sym_to} already exists!")

            os.makedirs(os.path.dirname(sym_to), exist_ok=True)
            os.symlink(sym_from, sym_to)
            self.state.add_symlink(destination)
        except Exception as err:
            raise RuntimeError(f"Failed to symlink file {origin} at {destination}") from err

    def _symlink_internal(self, origin, destination):
        """
        This is similar to _symlink, but it is meant to link an internal module to another
        already internal module (such as linking shell plugins)
        """
        try:
            sym_from = f"{self.dotfiles_path}/{origin}"
            sym_to = f"{self.dotfiles_path}/{destination}"

            if not os.path.exists(sym_from):
                raise RuntimeError(f"File {sym_from} was not found!")

            if os.path.exists(sym_to):
                # If the file is a symlink and it is already pointing to where we want to, just
                # include it into our state, otherwise let the user fix it.
                if os.path.islink(sym_to) and os.readlink(sym_to) == sym_from:
                    self.state.add_local_symlink(destination)
                    return

                raise RuntimeError(f"Path {sym_to} already exists!")

            # Internally we want to create relative links only
            relpath_from = os.path.relpath(sym_from, os.path.dirname(sym_to))

            os.makedirs(os.path.dirname(sym_to), exist_ok=True)
            os.symlink(relpath_from, sym_to)
            self.state.add_local_symlink(destination)
        except Exception as err:
            raise RuntimeError(f"Failed to symlink file {origin} at {destination}") from err

    def _clear_symlinks(self):
        """Clear all symlinks created by dotfiles, both internal and external ones"""
        for file in self.state.symlinks():
            symlink = f"{self.destination_path}/{file}"

            # Make sure we only ever delete symlinks we know we linked
            if os.path.islink(symlink) and os.readlink(symlink).startswith(self.dotfiles_path):
                os.remove(symlink)

        for file in self.state.local_symlinks():
            symlink = f"{self.dotfiles_path}/{file}"
            link_path = os.path.realpath(f"{os.path.dirname(symlink)}/{os.readlink(symlink)}")

            # Make sure we only ever delete symlinks we know we linked
            if os.path.islink(symlink) and link_path.startswith(self.dotfiles_path):
                os.remove(symlink)

        self.state.erase_symlinks()

CLI.start()
