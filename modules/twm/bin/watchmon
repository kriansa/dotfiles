#!/usr/bin/env python3
# vim: shiftwidth=4
#
# watchmon - Watch for monitor plug/unplug events
#
# Dependencies:
# - Required: xcffib       (Arch: python-xcffib)
# - Optional: acpi-daemon  (Arch: acpid)
#
# Useful constant locations:
# * /usr/include/X11/X.h
# * /usr/include/X11/extensions/Xrandr.h
# * /usr/include/X11/extensions/randr.h

import os, traceback, shutil, signal, sys, threading, subprocess
import json, datetime, argparse, zlib, re, glob, concurrent.futures
import xcffib, xcffib.xproto, xcffib.randr
from xcffib.randr import Connection, NotifyMask, ScreenChangeNotifyEvent

class CLI:
    """
    Get a list of monitors connected to Xorg and outputs a JSON object.

    If -w is passed, it starts watching for monitor plug/unplug events and
    print a JSON object whenever there are changes to the Xorg screen.

    It also considers ACPI events for lid open/close events for laptop displays.
    """

    @staticmethod
    def version():
        return "1.0.0"

    @staticmethod
    def run():
        parser = argparse.ArgumentParser(description = CLI.__doc__)
        parser.add_argument('-c', '--cmd', help = 'command to execute every time a change is detected. implies -w')
        parser.add_argument('-w', '--watch', action = 'store_true', help = 'continuously listen for status changes and prints every change to stdout')
        parser.add_argument('--ignore-lid', action = 'store_true', help = 'ignores lid open/close events')
        parser.add_argument('--version', action = 'version', version = CLI.version())

        args = parser.parse_args()
        monitor_status_reader = MonitorStatusReader(args.cmd, args.ignore_lid)

        if args.cmd is not None:
            args.watch = True

        if args.watch == True:
            monitor_status_reader.listen_changes()
        else:
            monitor_status_reader.output_current_state()


class X11Client:
    main_window_id = 0
    randr = None
    conn = None

    def __init__(self):
        self.conn = xcffib.connect()
        self.randr = self.conn(xcffib.randr.key)
        self.main_window_id = self.conn.get_setup().roots[self.conn.pref_screen].root

    def disconnect(self):
        self.conn.disconnect()

    def get_monitor_unique_id(self, output):
        edid = self.get_output_edid(output).raw
        return hex(zlib.crc32(edid))[2:].upper().rjust(8, '0')

    def get_output_edid(self, output):
        atoms = self.randr.ListOutputProperties(output).reply().atoms.list
        for atom in atoms:
            name = self.conn.core.GetAtomName(atom).reply().name.raw.decode('ascii')
            if name == "EDID":
                type_int = xcffib.xproto.Atom.INTEGER
                reply = self.randr.GetOutputProperty(output, atom, type_int, 0, 1024, False, False).reply()
                return reply.data

        return None

    def get_connected_monitors(self, consider_lid = True):
        res = self.randr.GetScreenResources(self.main_window_id).reply()

        connected_monitors = []
        for output in res.outputs:
            info = self.randr.GetOutputInfo(output, 0).reply()
            output_name = info.name.raw.decode("ascii")

            if info.connection != Connection.Connected:
                continue

            if consider_lid and not MonitorLid.instance().is_open(output_name):
                continue

            connected_monitors.append({
                "output": output_name,
                "edid_hash": self.get_monitor_unique_id(output),
            })

        return connected_monitors

    def listen_monitor_plug_events(self, callback):
        self.randr.SelectInput(self.main_window_id, NotifyMask.ScreenChange)
        self.conn.flush()
        last_change_ts = 0
        stop = threading.Event()

        # We use xcffib lib, which use Python's CFFI library under the hood in
        # order to provide a thin layer on top of XCB C lib.
        # As in any FFI library, whenever we switch control to the C code, Python's VM
        # loses control over that program until the routine C yields, which is
        # not the case for a blocking function such as `wait_for_event`.
        # In order to increase the responsiveness of this application and make sure we
        # are able to stop it quickly if needed, we'll run it within a separate
        # thread, leaving the main one free for user interactivity.
        def wait_for_x11_event(stop, event):
            event["value"] = self.conn.wait_for_event()
            stop.set()

        while True:
            event = {}
            stop.clear()
            threading.Thread(
                target = wait_for_x11_event,
                args=(stop, event,),
                # Daemonize this thread so Python can exit even with it still
                # running, which will likely be the case because it will be
                # blocked by the C function underneath.
                daemon = True,
            ).start()

            # Wait for the blocking operation
            stop.wait()

            # Ignore unrelated events
            if type(event["value"]) != ScreenChangeNotifyEvent:
                continue

            # Ignore duplicated events
            if last_change_ts == event["value"].config_timestamp:
                continue

            last_change_ts = event["value"].config_timestamp
            callback()


class MonitorLid:
    lid_state_file = None
    is_present = None

    # Singleton
    _instance = None

    @classmethod
    def instance(klass):
        if klass._instance is None:
            klass._instance = klass()
        return klass._instance

    def __init__(self):
        lids = glob.glob("/proc/acpi/button/lid/*/state")
        self.lid_state_file = lids[0] if len(lids) == 1 else None
        self.is_present = shutil.which('acpi_listen') is not None and \
            self.lid_state_file is not None

    def is_open(self, output_name = None):
        # If we don't have ACPI, then the lid is always open
        if not self.is_present:
            return True

        # If this is not a "laptop monitor", then the "lid" is open
        # Stolen from autorandr
        if output_name is not None and not re.match(r'(eDP(-?[0-9]\+)*|LVDS(-?[0-9]\+)*)', output_name):
            return True

        with open(self.lid_state_file) as f:
            return "open" in f.read()


class MonitorStatusReader:
    x11_client = None
    consider_lid = True
    cmd = None

    def __init__(self, cmd = None, ignore_lid = False):
        self.x11_client = X11Client()
        self.cmd = cmd
        self.consider_lid = not ignore_lid and MonitorLid.instance().is_present

    def listen_changes(self):
        signal.signal(signal.SIGINT, self._exit_handler)

        # Execute the two blocking operations in a ThreadPool
        with concurrent.futures.ThreadPoolExecutor(max_workers = 2) as executor:
            futures = []

            # Print the initial state right off the bat
            futures.append(executor.submit(self.output_current_state))

            # Start the XCB listener
            futures.append(executor.submit(self._x11_listener))

            # And if available, start the ACPI listener
            if self.consider_lid:
                futures.append(executor.submit(self._acpi_listener))

            # Handle errors
            for future in concurrent.futures.as_completed(futures):
                try:
                    future.result()
                except Exception as exc:
                    traceback.print_exception(exc)
                    os._exit(0)

    def output_current_state(self):
        connected = self.x11_client.get_connected_monitors(self.consider_lid)
        ts = datetime.datetime.now().astimezone().replace(microsecond=0).isoformat()

        if self.cmd is not None:
            # Formats the output in a easily parseable string for primitive
            # tools like bash that doesn't have easy access to JSON parsers.
            # If no monitor is connected, a blank string is passed instead
            #
            # E.g.: HDMI-0:FD067AC1 eDP-1:4AE76F8C4
            monitors = [f"{s['output']}:{s['edid_hash']}" for s in connected]
            subprocess.run([self.cmd, *monitors], timeout = 10)
        else:
            # Simply outputs a JSON-formatted object to stdout
            output = { "ts": ts, "plugged": connected }
            print(json.dumps(output))

    def _acpi_listener(self):
        p = subprocess.Popen(
            [shutil.which('acpi_listen')],
            stdout = subprocess.PIPE, stderr = subprocess.STDOUT,
            text = True, bufsize = 1,
        )

        with p.stdout:
            last_state = "open" if MonitorLid.instance().is_open() else "closed"
            current_state = last_state
            for line in iter(p.stdout.readline, ''):
                if "button/lid" in line:
                    current_state = "open" if "open" in line else "closed"
                    if current_state == last_state:
                        continue

                    last_state = current_state
                    self.output_current_state()

        p.wait()

    def _x11_listener(self):
        self.x11_client.listen_monitor_plug_events(self.output_current_state)

    def _exit_handler(self, *_):
        print("SIGINT received, exiting...", file = sys.stderr)
        os._exit(0)

CLI.run()
