#!/usr/bin/env bash
#
# Desktop Handler for Watchmon
# Receives a payload from watchmon and automatically configure the displays using xrandr

# Match a configuration using the pattern "<monitor_quantity>_<Output-Name:EDID>+<Output-Name:EDID>"
# Here we can define what to do when a monitor combination is matched, so we can execute the right
# commands such as `xrandr` for display layouts and disabling features such as notifications, etc.
setup() {
  case "$1" in
    # Just the main screen
    1_HDMI-0:*) xrandr --output HDMI-0 --preferred --primary ;;

    # Handle exceptional cases: no monitor or no configuration
    0_) echo "No monitor detected." ;;
    *) echo "Screen setup not configured: $1" ;;
  esac
}

# Wrapper on top of `xrandr` that accounts for disconnected monitors that should be turned off if
# they aren't connected. This means you don't need to worry about setting existing outputs off when
# currently you only need to setup a single monitor.
xrandr() {
  args=($@)

  # ENHANCE: This algo is up to O(N^2). In this case is just fine because it only handles small sets
  # of data, but if there are a simple solution that can make it more efficient, I'm all for it.
  while IFS= read -r available_output; do
    has_match=0
    for plugged_output in "${MONITORS[@]}"; do
      plugged_output="${plugged_output%%:*}"
      test "$available_output" = "$plugged_output" && has_match=1
    done

    # If an available output is not present in the plugged outputs, it means it's disconnected,
    # hence added for being turned off in case it was previously configured
    test $has_match = 0 && args+=("--output" "$available_output" "--off")
  done < <(command xrandr -q | grep -Eo "^[[:alpha:]]+-[[:digit:]]+")

  command xrandr "${args[@]}"
}

main() {
  # Get all monitors in an array and as a single string, joined by +
  MONITORS=($@)
  IFS="+"; MONITORS_STRING="$*"; IFS=$'\n'

  # The amount of plugged monitors passed as parameters
  local total="$#"

  setup "${total}_${MONITORS_STRING}"
}

main "$@"
